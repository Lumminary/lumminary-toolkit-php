<?php
/**
 * LumminaryAPISpecApi
 * PHP version 5
 *
 * @category Class
 * @package  Lumminary\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Lumminary API
 *
 * A general-purpose API for accessing genomic data
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Lumminary\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Lumminary\Client\ApiException;
use Lumminary\Client\Configuration;
use Lumminary\Client\HeaderSelector;
use Lumminary\Client\ObjectSerializer;

/**
 * LumminaryAPISpecApi Class Doc Comment
 *
 * @category Class
 * @package  Lumminary\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class LumminaryAPISpecApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getAuthorizationsQueue
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $seqNumStart The first sequence number from which to fetch (the sequence number of the last processed authorization) (optional)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\Authorization[]
     */
    public function getAuthorizationsQueue($productId, $seqNumStart = null, $xFields = null)
    {
        list($response) = $this->getAuthorizationsQueueWithHttpInfo($productId, $seqNumStart, $xFields);
        return $response;
    }

    /**
     * Operation getAuthorizationsQueueWithHttpInfo
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $seqNumStart The first sequence number from which to fetch (the sequence number of the last processed authorization) (optional)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\Authorization[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getAuthorizationsQueueWithHttpInfo($productId, $seqNumStart = null, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\Authorization[]';
        $request = $this->getAuthorizationsQueueRequest($productId, $seqNumStart, $xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\Authorization[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAuthorizationsQueueAsync
     *
     * 
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $seqNumStart The first sequence number from which to fetch (the sequence number of the last processed authorization) (optional)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAuthorizationsQueueAsync($productId, $seqNumStart = null, $xFields = null)
    {
        return $this->getAuthorizationsQueueAsyncWithHttpInfo($productId, $seqNumStart, $xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAuthorizationsQueueAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $seqNumStart The first sequence number from which to fetch (the sequence number of the last processed authorization) (optional)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAuthorizationsQueueAsyncWithHttpInfo($productId, $seqNumStart = null, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\Authorization[]';
        $request = $this->getAuthorizationsQueueRequest($productId, $seqNumStart, $xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAuthorizationsQueue'
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $seqNumStart The first sequence number from which to fetch (the sequence number of the last processed authorization) (optional)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAuthorizationsQueueRequest($productId, $seqNumStart = null, $xFields = null)
    {
        // verify the required parameter 'productId' is set
        if ($productId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $productId when calling getAuthorizationsQueue'
            );
        }

        $resourcePath = '/products/{productId}/authorizations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($seqNumStart !== null) {
            $queryParams['seq_num_start'] = ObjectSerializer::toQueryValue($seqNumStart);
        }
        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }

        // path params
        if ($productId !== null) {
            $resourcePath = str_replace(
                '{' . 'productId' . '}',
                ObjectSerializer::toPathValue($productId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getClientGene
     *
     * Get gene by symbol
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $geneSymbol The symbol of a gene to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\ClientGene
     */
    public function getClientGene($clientId, $datasetId, $geneSymbol, $xFields = null)
    {
        list($response) = $this->getClientGeneWithHttpInfo($clientId, $datasetId, $geneSymbol, $xFields);
        return $response;
    }

    /**
     * Operation getClientGeneWithHttpInfo
     *
     * Get gene by symbol
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $geneSymbol The symbol of a gene to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\ClientGene, HTTP status code, HTTP response headers (array of strings)
     */
    public function getClientGeneWithHttpInfo($clientId, $datasetId, $geneSymbol, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ClientGene';
        $request = $this->getClientGeneRequest($clientId, $datasetId, $geneSymbol, $xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\ClientGene',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getClientGeneAsync
     *
     * Get gene by symbol
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $geneSymbol The symbol of a gene to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClientGeneAsync($clientId, $datasetId, $geneSymbol, $xFields = null)
    {
        return $this->getClientGeneAsyncWithHttpInfo($clientId, $datasetId, $geneSymbol, $xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getClientGeneAsyncWithHttpInfo
     *
     * Get gene by symbol
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $geneSymbol The symbol of a gene to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClientGeneAsyncWithHttpInfo($clientId, $datasetId, $geneSymbol, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ClientGene';
        $request = $this->getClientGeneRequest($clientId, $datasetId, $geneSymbol, $xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getClientGene'
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $geneSymbol The symbol of a gene to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getClientGeneRequest($clientId, $datasetId, $geneSymbol, $xFields = null)
    {
        // verify the required parameter 'clientId' is set
        if ($clientId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $clientId when calling getClientGene'
            );
        }
        // verify the required parameter 'datasetId' is set
        if ($datasetId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $datasetId when calling getClientGene'
            );
        }
        // verify the required parameter 'geneSymbol' is set
        if ($geneSymbol === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $geneSymbol when calling getClientGene'
            );
        }

        $resourcePath = '/clients/{clientId}/datasets/{datasetId}/genes/{geneSymbol}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }

        // path params
        if ($clientId !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($clientId),
                $resourcePath
            );
        }
        // path params
        if ($datasetId !== null) {
            $resourcePath = str_replace(
                '{' . 'datasetId' . '}',
                ObjectSerializer::toPathValue($datasetId),
                $resourcePath
            );
        }
        // path params
        if ($geneSymbol !== null) {
            $resourcePath = str_replace(
                '{' . 'geneSymbol' . '}',
                ObjectSerializer::toPathValue($geneSymbol),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getClientSnp
     *
     * Get SNP information
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $snpId The rsId of a SNP to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\ClientSNP
     */
    public function getClientSnp($clientId, $datasetId, $snpId, $xFields = null)
    {
        list($response) = $this->getClientSnpWithHttpInfo($clientId, $datasetId, $snpId, $xFields);
        return $response;
    }

    /**
     * Operation getClientSnpWithHttpInfo
     *
     * Get SNP information
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $snpId The rsId of a SNP to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\ClientSNP, HTTP status code, HTTP response headers (array of strings)
     */
    public function getClientSnpWithHttpInfo($clientId, $datasetId, $snpId, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ClientSNP';
        $request = $this->getClientSnpRequest($clientId, $datasetId, $snpId, $xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\ClientSNP',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getClientSnpAsync
     *
     * Get SNP information
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $snpId The rsId of a SNP to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClientSnpAsync($clientId, $datasetId, $snpId, $xFields = null)
    {
        return $this->getClientSnpAsyncWithHttpInfo($clientId, $datasetId, $snpId, $xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getClientSnpAsyncWithHttpInfo
     *
     * Get SNP information
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $snpId The rsId of a SNP to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClientSnpAsyncWithHttpInfo($clientId, $datasetId, $snpId, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ClientSNP';
        $request = $this->getClientSnpRequest($clientId, $datasetId, $snpId, $xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getClientSnp'
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $snpId The rsId of a SNP to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getClientSnpRequest($clientId, $datasetId, $snpId, $xFields = null)
    {
        // verify the required parameter 'clientId' is set
        if ($clientId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $clientId when calling getClientSnp'
            );
        }
        // verify the required parameter 'datasetId' is set
        if ($datasetId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $datasetId when calling getClientSnp'
            );
        }
        // verify the required parameter 'snpId' is set
        if ($snpId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snpId when calling getClientSnp'
            );
        }

        $resourcePath = '/clients/{clientId}/datasets/{datasetId}/snps/{snpId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }

        // path params
        if ($clientId !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($clientId),
                $resourcePath
            );
        }
        // path params
        if ($datasetId !== null) {
            $resourcePath = str_replace(
                '{' . 'datasetId' . '}',
                ObjectSerializer::toPathValue($datasetId),
                $resourcePath
            );
        }
        // path params
        if ($snpId !== null) {
            $resourcePath = str_replace(
                '{' . 'snpId' . '}',
                ObjectSerializer::toPathValue($snpId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getClientSnpGroup
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\ClientSNP[]
     */
    public function getClientSnpGroup($clientId, $datasetId, $xFields = null)
    {
        list($response) = $this->getClientSnpGroupWithHttpInfo($clientId, $datasetId, $xFields);
        return $response;
    }

    /**
     * Operation getClientSnpGroupWithHttpInfo
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\ClientSNP[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getClientSnpGroupWithHttpInfo($clientId, $datasetId, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ClientSNP[]';
        $request = $this->getClientSnpGroupRequest($clientId, $datasetId, $xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\ClientSNP[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getClientSnpGroupAsync
     *
     * 
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClientSnpGroupAsync($clientId, $datasetId, $xFields = null)
    {
        return $this->getClientSnpGroupAsyncWithHttpInfo($clientId, $datasetId, $xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getClientSnpGroupAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClientSnpGroupAsyncWithHttpInfo($clientId, $datasetId, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ClientSNP[]';
        $request = $this->getClientSnpGroupRequest($clientId, $datasetId, $xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getClientSnpGroup'
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getClientSnpGroupRequest($clientId, $datasetId, $xFields = null)
    {
        // verify the required parameter 'clientId' is set
        if ($clientId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $clientId when calling getClientSnpGroup'
            );
        }
        // verify the required parameter 'datasetId' is set
        if ($datasetId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $datasetId when calling getClientSnpGroup'
            );
        }

        $resourcePath = '/clients/{clientId}/datasets/{datasetId}/snps/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }

        // path params
        if ($clientId !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($clientId),
                $resourcePath
            );
        }
        // path params
        if ($datasetId !== null) {
            $resourcePath = str_replace(
                '{' . 'datasetId' . '}',
                ObjectSerializer::toPathValue($datasetId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGene
     *
     * Generic gene information
     *
     * @param  string $databaseName The name of the database to search. E.g: Genbank (required)
     * @param  string $accession The accession within the selected database (required)
     * @param  int $dbsnpBuild The dbSNP build for which to consider snps belonging to the gene. Defaults to 149 (optional, default to 149)
     * @param  string $referenceGenome The reference genome for which gene annotations will be returned. Defaults to GRCh37p13 (optional, default to GRCH37P13)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\PublicGene
     */
    public function getGene($databaseName, $accession, $dbsnpBuild = '149', $referenceGenome = 'GRCH37P13', $xFields = null)
    {
        list($response) = $this->getGeneWithHttpInfo($databaseName, $accession, $dbsnpBuild, $referenceGenome, $xFields);
        return $response;
    }

    /**
     * Operation getGeneWithHttpInfo
     *
     * Generic gene information
     *
     * @param  string $databaseName The name of the database to search. E.g: Genbank (required)
     * @param  string $accession The accession within the selected database (required)
     * @param  int $dbsnpBuild The dbSNP build for which to consider snps belonging to the gene. Defaults to 149 (optional, default to 149)
     * @param  string $referenceGenome The reference genome for which gene annotations will be returned. Defaults to GRCh37p13 (optional, default to GRCH37P13)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\PublicGene, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGeneWithHttpInfo($databaseName, $accession, $dbsnpBuild = '149', $referenceGenome = 'GRCH37P13', $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\PublicGene';
        $request = $this->getGeneRequest($databaseName, $accession, $dbsnpBuild, $referenceGenome, $xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\PublicGene',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGeneAsync
     *
     * Generic gene information
     *
     * @param  string $databaseName The name of the database to search. E.g: Genbank (required)
     * @param  string $accession The accession within the selected database (required)
     * @param  int $dbsnpBuild The dbSNP build for which to consider snps belonging to the gene. Defaults to 149 (optional, default to 149)
     * @param  string $referenceGenome The reference genome for which gene annotations will be returned. Defaults to GRCh37p13 (optional, default to GRCH37P13)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGeneAsync($databaseName, $accession, $dbsnpBuild = '149', $referenceGenome = 'GRCH37P13', $xFields = null)
    {
        return $this->getGeneAsyncWithHttpInfo($databaseName, $accession, $dbsnpBuild, $referenceGenome, $xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGeneAsyncWithHttpInfo
     *
     * Generic gene information
     *
     * @param  string $databaseName The name of the database to search. E.g: Genbank (required)
     * @param  string $accession The accession within the selected database (required)
     * @param  int $dbsnpBuild The dbSNP build for which to consider snps belonging to the gene. Defaults to 149 (optional, default to 149)
     * @param  string $referenceGenome The reference genome for which gene annotations will be returned. Defaults to GRCh37p13 (optional, default to GRCH37P13)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGeneAsyncWithHttpInfo($databaseName, $accession, $dbsnpBuild = '149', $referenceGenome = 'GRCH37P13', $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\PublicGene';
        $request = $this->getGeneRequest($databaseName, $accession, $dbsnpBuild, $referenceGenome, $xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGene'
     *
     * @param  string $databaseName The name of the database to search. E.g: Genbank (required)
     * @param  string $accession The accession within the selected database (required)
     * @param  int $dbsnpBuild The dbSNP build for which to consider snps belonging to the gene. Defaults to 149 (optional, default to 149)
     * @param  string $referenceGenome The reference genome for which gene annotations will be returned. Defaults to GRCh37p13 (optional, default to GRCH37P13)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGeneRequest($databaseName, $accession, $dbsnpBuild = '149', $referenceGenome = 'GRCH37P13', $xFields = null)
    {
        // verify the required parameter 'databaseName' is set
        if ($databaseName === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $databaseName when calling getGene'
            );
        }
        // verify the required parameter 'accession' is set
        if ($accession === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accession when calling getGene'
            );
        }

        $resourcePath = '/reference/genes/databases/{databaseName}/accessions/{accession}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dbsnpBuild !== null) {
            $queryParams['dbsnp_build'] = ObjectSerializer::toQueryValue($dbsnpBuild);
        }
        // query params
        if ($referenceGenome !== null) {
            $queryParams['reference_genome'] = ObjectSerializer::toQueryValue($referenceGenome);
        }
        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }

        // path params
        if ($databaseName !== null) {
            $resourcePath = str_replace(
                '{' . 'databaseName' . '}',
                ObjectSerializer::toPathValue($databaseName),
                $resourcePath
            );
        }
        // path params
        if ($accession !== null) {
            $resourcePath = str_replace(
                '{' . 'accession' . '}',
                ObjectSerializer::toPathValue($accession),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProduct
     *
     * Get product details
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\Product
     */
    public function getProduct($productId, $xFields = null)
    {
        list($response) = $this->getProductWithHttpInfo($productId, $xFields);
        return $response;
    }

    /**
     * Operation getProductWithHttpInfo
     *
     * Get product details
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\Product, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProductWithHttpInfo($productId, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\Product';
        $request = $this->getProductRequest($productId, $xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\Product',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProductAsync
     *
     * Get product details
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductAsync($productId, $xFields = null)
    {
        return $this->getProductAsyncWithHttpInfo($productId, $xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProductAsyncWithHttpInfo
     *
     * Get product details
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductAsyncWithHttpInfo($productId, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\Product';
        $request = $this->getProductRequest($productId, $xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProduct'
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProductRequest($productId, $xFields = null)
    {
        // verify the required parameter 'productId' is set
        if ($productId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $productId when calling getProduct'
            );
        }

        $resourcePath = '/products/{productId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }

        // path params
        if ($productId !== null) {
            $resourcePath = str_replace(
                '{' . 'productId' . '}',
                ObjectSerializer::toPathValue($productId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProductAuthorization
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\Authorization
     */
    public function getProductAuthorization($productId, $authorizationId, $xFields = null)
    {
        list($response) = $this->getProductAuthorizationWithHttpInfo($productId, $authorizationId, $xFields);
        return $response;
    }

    /**
     * Operation getProductAuthorizationWithHttpInfo
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\Authorization, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProductAuthorizationWithHttpInfo($productId, $authorizationId, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\Authorization';
        $request = $this->getProductAuthorizationRequest($productId, $authorizationId, $xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\Authorization',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProductAuthorizationAsync
     *
     * 
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductAuthorizationAsync($productId, $authorizationId, $xFields = null)
    {
        return $this->getProductAuthorizationAsyncWithHttpInfo($productId, $authorizationId, $xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProductAuthorizationAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductAuthorizationAsyncWithHttpInfo($productId, $authorizationId, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\Authorization';
        $request = $this->getProductAuthorizationRequest($productId, $authorizationId, $xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProductAuthorization'
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProductAuthorizationRequest($productId, $authorizationId, $xFields = null)
    {
        // verify the required parameter 'productId' is set
        if ($productId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $productId when calling getProductAuthorization'
            );
        }
        // verify the required parameter 'authorizationId' is set
        if ($authorizationId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorizationId when calling getProductAuthorization'
            );
        }

        $resourcePath = '/products/{productId}/authorizations/{authorizationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }

        // path params
        if ($productId !== null) {
            $resourcePath = str_replace(
                '{' . 'productId' . '}',
                ObjectSerializer::toPathValue($productId),
                $resourcePath
            );
        }
        // path params
        if ($authorizationId !== null) {
            $resourcePath = str_replace(
                '{' . 'authorizationId' . '}',
                ObjectSerializer::toPathValue($authorizationId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getReferenceChromosome
     *
     * Sequence for a region of the reference genome
     *
     * @param  string $genomeBuildAccession The accession of the reference genome (required)
     * @param  string $chromosomeAccession The accession to the chromosome (required)
     * @param  int $rangeStart Location on the chromosome (required)
     * @param  int $rangeStop Location on the chromosome (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\ReferenceSequence
     */
    public function getReferenceChromosome($genomeBuildAccession, $chromosomeAccession, $rangeStart, $rangeStop, $xFields = null)
    {
        list($response) = $this->getReferenceChromosomeWithHttpInfo($genomeBuildAccession, $chromosomeAccession, $rangeStart, $rangeStop, $xFields);
        return $response;
    }

    /**
     * Operation getReferenceChromosomeWithHttpInfo
     *
     * Sequence for a region of the reference genome
     *
     * @param  string $genomeBuildAccession The accession of the reference genome (required)
     * @param  string $chromosomeAccession The accession to the chromosome (required)
     * @param  int $rangeStart Location on the chromosome (required)
     * @param  int $rangeStop Location on the chromosome (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\ReferenceSequence, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReferenceChromosomeWithHttpInfo($genomeBuildAccession, $chromosomeAccession, $rangeStart, $rangeStop, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ReferenceSequence';
        $request = $this->getReferenceChromosomeRequest($genomeBuildAccession, $chromosomeAccession, $rangeStart, $rangeStop, $xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\ReferenceSequence',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReferenceChromosomeAsync
     *
     * Sequence for a region of the reference genome
     *
     * @param  string $genomeBuildAccession The accession of the reference genome (required)
     * @param  string $chromosomeAccession The accession to the chromosome (required)
     * @param  int $rangeStart Location on the chromosome (required)
     * @param  int $rangeStop Location on the chromosome (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReferenceChromosomeAsync($genomeBuildAccession, $chromosomeAccession, $rangeStart, $rangeStop, $xFields = null)
    {
        return $this->getReferenceChromosomeAsyncWithHttpInfo($genomeBuildAccession, $chromosomeAccession, $rangeStart, $rangeStop, $xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReferenceChromosomeAsyncWithHttpInfo
     *
     * Sequence for a region of the reference genome
     *
     * @param  string $genomeBuildAccession The accession of the reference genome (required)
     * @param  string $chromosomeAccession The accession to the chromosome (required)
     * @param  int $rangeStart Location on the chromosome (required)
     * @param  int $rangeStop Location on the chromosome (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReferenceChromosomeAsyncWithHttpInfo($genomeBuildAccession, $chromosomeAccession, $rangeStart, $rangeStop, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ReferenceSequence';
        $request = $this->getReferenceChromosomeRequest($genomeBuildAccession, $chromosomeAccession, $rangeStart, $rangeStop, $xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReferenceChromosome'
     *
     * @param  string $genomeBuildAccession The accession of the reference genome (required)
     * @param  string $chromosomeAccession The accession to the chromosome (required)
     * @param  int $rangeStart Location on the chromosome (required)
     * @param  int $rangeStop Location on the chromosome (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getReferenceChromosomeRequest($genomeBuildAccession, $chromosomeAccession, $rangeStart, $rangeStop, $xFields = null)
    {
        // verify the required parameter 'genomeBuildAccession' is set
        if ($genomeBuildAccession === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $genomeBuildAccession when calling getReferenceChromosome'
            );
        }
        // verify the required parameter 'chromosomeAccession' is set
        if ($chromosomeAccession === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chromosomeAccession when calling getReferenceChromosome'
            );
        }
        // verify the required parameter 'rangeStart' is set
        if ($rangeStart === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rangeStart when calling getReferenceChromosome'
            );
        }
        // verify the required parameter 'rangeStop' is set
        if ($rangeStop === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rangeStop when calling getReferenceChromosome'
            );
        }

        $resourcePath = '/reference/genomes/{genomeBuildAccession}/chromosomes/{chromosomeAccession}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($rangeStart !== null) {
            $queryParams['range_start'] = ObjectSerializer::toQueryValue($rangeStart);
        }
        // query params
        if ($rangeStop !== null) {
            $queryParams['range_stop'] = ObjectSerializer::toQueryValue($rangeStop);
        }
        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }

        // path params
        if ($genomeBuildAccession !== null) {
            $resourcePath = str_replace(
                '{' . 'genomeBuildAccession' . '}',
                ObjectSerializer::toPathValue($genomeBuildAccession),
                $resourcePath
            );
        }
        // path params
        if ($chromosomeAccession !== null) {
            $resourcePath = str_replace(
                '{' . 'chromosomeAccession' . '}',
                ObjectSerializer::toPathValue($chromosomeAccession),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getReferenceGenome
     *
     * Reference genome metadata
     *
     * @param  string $genomeBuildAccession genomeBuildAccession (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\ReferenceChromosomeOverview[]
     */
    public function getReferenceGenome($genomeBuildAccession, $xFields = null)
    {
        list($response) = $this->getReferenceGenomeWithHttpInfo($genomeBuildAccession, $xFields);
        return $response;
    }

    /**
     * Operation getReferenceGenomeWithHttpInfo
     *
     * Reference genome metadata
     *
     * @param  string $genomeBuildAccession (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\ReferenceChromosomeOverview[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getReferenceGenomeWithHttpInfo($genomeBuildAccession, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ReferenceChromosomeOverview[]';
        $request = $this->getReferenceGenomeRequest($genomeBuildAccession, $xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\ReferenceChromosomeOverview[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReferenceGenomeAsync
     *
     * Reference genome metadata
     *
     * @param  string $genomeBuildAccession (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReferenceGenomeAsync($genomeBuildAccession, $xFields = null)
    {
        return $this->getReferenceGenomeAsyncWithHttpInfo($genomeBuildAccession, $xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReferenceGenomeAsyncWithHttpInfo
     *
     * Reference genome metadata
     *
     * @param  string $genomeBuildAccession (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReferenceGenomeAsyncWithHttpInfo($genomeBuildAccession, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ReferenceChromosomeOverview[]';
        $request = $this->getReferenceGenomeRequest($genomeBuildAccession, $xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReferenceGenome'
     *
     * @param  string $genomeBuildAccession (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getReferenceGenomeRequest($genomeBuildAccession, $xFields = null)
    {
        // verify the required parameter 'genomeBuildAccession' is set
        if ($genomeBuildAccession === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $genomeBuildAccession when calling getReferenceGenome'
            );
        }

        $resourcePath = '/reference/genomes/{genomeBuildAccession}/chromosomes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }

        // path params
        if ($genomeBuildAccession !== null) {
            $resourcePath = str_replace(
                '{' . 'genomeBuildAccession' . '}',
                ObjectSerializer::toPathValue($genomeBuildAccession),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getReferenceGenomesGroup
     *
     * Reference genome builds
     *
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\ReferenceGenomeOverview[]
     */
    public function getReferenceGenomesGroup($xFields = null)
    {
        list($response) = $this->getReferenceGenomesGroupWithHttpInfo($xFields);
        return $response;
    }

    /**
     * Operation getReferenceGenomesGroupWithHttpInfo
     *
     * Reference genome builds
     *
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\ReferenceGenomeOverview[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getReferenceGenomesGroupWithHttpInfo($xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ReferenceGenomeOverview[]';
        $request = $this->getReferenceGenomesGroupRequest($xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\ReferenceGenomeOverview[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReferenceGenomesGroupAsync
     *
     * Reference genome builds
     *
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReferenceGenomesGroupAsync($xFields = null)
    {
        return $this->getReferenceGenomesGroupAsyncWithHttpInfo($xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReferenceGenomesGroupAsyncWithHttpInfo
     *
     * Reference genome builds
     *
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReferenceGenomesGroupAsyncWithHttpInfo($xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ReferenceGenomeOverview[]';
        $request = $this->getReferenceGenomesGroupRequest($xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReferenceGenomesGroup'
     *
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getReferenceGenomesGroupRequest($xFields = null)
    {

        $resourcePath = '/reference/genomes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getReferenceSnp
     *
     * Reference SNP data
     *
     * @param  string $snpAccession The rsId of the SNP (required)
     * @param  int $dbsnpVersion The dbSNP build. Defaults to 149 (optional, default to 149)
     * @param  string $grchVersion The GRCh build on which to place snips. Defaults to GRCh37p13 (optional, default to GRCH37P13)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\PublicSNP
     */
    public function getReferenceSnp($snpAccession, $dbsnpVersion = '149', $grchVersion = 'GRCH37P13', $xFields = null)
    {
        list($response) = $this->getReferenceSnpWithHttpInfo($snpAccession, $dbsnpVersion, $grchVersion, $xFields);
        return $response;
    }

    /**
     * Operation getReferenceSnpWithHttpInfo
     *
     * Reference SNP data
     *
     * @param  string $snpAccession The rsId of the SNP (required)
     * @param  int $dbsnpVersion The dbSNP build. Defaults to 149 (optional, default to 149)
     * @param  string $grchVersion The GRCh build on which to place snips. Defaults to GRCh37p13 (optional, default to GRCH37P13)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\PublicSNP, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReferenceSnpWithHttpInfo($snpAccession, $dbsnpVersion = '149', $grchVersion = 'GRCH37P13', $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\PublicSNP';
        $request = $this->getReferenceSnpRequest($snpAccession, $dbsnpVersion, $grchVersion, $xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\PublicSNP',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReferenceSnpAsync
     *
     * Reference SNP data
     *
     * @param  string $snpAccession The rsId of the SNP (required)
     * @param  int $dbsnpVersion The dbSNP build. Defaults to 149 (optional, default to 149)
     * @param  string $grchVersion The GRCh build on which to place snips. Defaults to GRCh37p13 (optional, default to GRCH37P13)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReferenceSnpAsync($snpAccession, $dbsnpVersion = '149', $grchVersion = 'GRCH37P13', $xFields = null)
    {
        return $this->getReferenceSnpAsyncWithHttpInfo($snpAccession, $dbsnpVersion, $grchVersion, $xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReferenceSnpAsyncWithHttpInfo
     *
     * Reference SNP data
     *
     * @param  string $snpAccession The rsId of the SNP (required)
     * @param  int $dbsnpVersion The dbSNP build. Defaults to 149 (optional, default to 149)
     * @param  string $grchVersion The GRCh build on which to place snips. Defaults to GRCh37p13 (optional, default to GRCH37P13)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReferenceSnpAsyncWithHttpInfo($snpAccession, $dbsnpVersion = '149', $grchVersion = 'GRCH37P13', $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\PublicSNP';
        $request = $this->getReferenceSnpRequest($snpAccession, $dbsnpVersion, $grchVersion, $xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReferenceSnp'
     *
     * @param  string $snpAccession The rsId of the SNP (required)
     * @param  int $dbsnpVersion The dbSNP build. Defaults to 149 (optional, default to 149)
     * @param  string $grchVersion The GRCh build on which to place snips. Defaults to GRCh37p13 (optional, default to GRCH37P13)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getReferenceSnpRequest($snpAccession, $dbsnpVersion = '149', $grchVersion = 'GRCH37P13', $xFields = null)
    {
        // verify the required parameter 'snpAccession' is set
        if ($snpAccession === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snpAccession when calling getReferenceSnp'
            );
        }

        $resourcePath = '/reference/snps/{snpAccession}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dbsnpVersion !== null) {
            $queryParams['dbsnp_version'] = ObjectSerializer::toQueryValue($dbsnpVersion);
        }
        // query params
        if ($grchVersion !== null) {
            $queryParams['grch_version'] = ObjectSerializer::toQueryValue($grchVersion);
        }
        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }

        // path params
        if ($snpAccession !== null) {
            $resourcePath = str_replace(
                '{' . 'snpAccession' . '}',
                ObjectSerializer::toPathValue($snpAccession),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postAuthorizationResultCredentials
     *
     * Provide a result for the authorization
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  string $credentialsUsername Credentials for accessing the result. Includes password, username and url (optional)
     * @param  string $credentialsPassword Credentials for accessing the result. Includes password, username and url (optional)
     * @param  string $reportUrl Credentials for accessing the result. Includes password, username and url (optional)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\ReportCredentials
     */
    public function postAuthorizationResultCredentials($productId, $authorizationId, $credentialsUsername = null, $credentialsPassword = null, $reportUrl = null, $notifyClient = 'true', $xFields = null)
    {
        list($response) = $this->postAuthorizationResultCredentialsWithHttpInfo($productId, $authorizationId, $credentialsUsername, $credentialsPassword, $reportUrl, $notifyClient, $xFields);
        return $response;
    }

    /**
     * Operation postAuthorizationResultCredentialsWithHttpInfo
     *
     * Provide a result for the authorization
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  string $credentialsUsername Credentials for accessing the result. Includes password, username and url (optional)
     * @param  string $credentialsPassword Credentials for accessing the result. Includes password, username and url (optional)
     * @param  string $reportUrl Credentials for accessing the result. Includes password, username and url (optional)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\ReportCredentials, HTTP status code, HTTP response headers (array of strings)
     */
    public function postAuthorizationResultCredentialsWithHttpInfo($productId, $authorizationId, $credentialsUsername = null, $credentialsPassword = null, $reportUrl = null, $notifyClient = 'true', $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ReportCredentials';
        $request = $this->postAuthorizationResultCredentialsRequest($productId, $authorizationId, $credentialsUsername, $credentialsPassword, $reportUrl, $notifyClient, $xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\ReportCredentials',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postAuthorizationResultCredentialsAsync
     *
     * Provide a result for the authorization
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  string $credentialsUsername Credentials for accessing the result. Includes password, username and url (optional)
     * @param  string $credentialsPassword Credentials for accessing the result. Includes password, username and url (optional)
     * @param  string $reportUrl Credentials for accessing the result. Includes password, username and url (optional)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAuthorizationResultCredentialsAsync($productId, $authorizationId, $credentialsUsername = null, $credentialsPassword = null, $reportUrl = null, $notifyClient = 'true', $xFields = null)
    {
        return $this->postAuthorizationResultCredentialsAsyncWithHttpInfo($productId, $authorizationId, $credentialsUsername, $credentialsPassword, $reportUrl, $notifyClient, $xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postAuthorizationResultCredentialsAsyncWithHttpInfo
     *
     * Provide a result for the authorization
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  string $credentialsUsername Credentials for accessing the result. Includes password, username and url (optional)
     * @param  string $credentialsPassword Credentials for accessing the result. Includes password, username and url (optional)
     * @param  string $reportUrl Credentials for accessing the result. Includes password, username and url (optional)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAuthorizationResultCredentialsAsyncWithHttpInfo($productId, $authorizationId, $credentialsUsername = null, $credentialsPassword = null, $reportUrl = null, $notifyClient = 'true', $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ReportCredentials';
        $request = $this->postAuthorizationResultCredentialsRequest($productId, $authorizationId, $credentialsUsername, $credentialsPassword, $reportUrl, $notifyClient, $xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postAuthorizationResultCredentials'
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  string $credentialsUsername Credentials for accessing the result. Includes password, username and url (optional)
     * @param  string $credentialsPassword Credentials for accessing the result. Includes password, username and url (optional)
     * @param  string $reportUrl Credentials for accessing the result. Includes password, username and url (optional)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postAuthorizationResultCredentialsRequest($productId, $authorizationId, $credentialsUsername = null, $credentialsPassword = null, $reportUrl = null, $notifyClient = 'true', $xFields = null)
    {
        // verify the required parameter 'productId' is set
        if ($productId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $productId when calling postAuthorizationResultCredentials'
            );
        }
        // verify the required parameter 'authorizationId' is set
        if ($authorizationId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorizationId when calling postAuthorizationResultCredentials'
            );
        }

        $resourcePath = '/products/{productId}/authorizations/{authorizationId}/credentials';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($notifyClient !== null) {
            $queryParams['notify_client'] = ObjectSerializer::toQueryValue($notifyClient);
        }
        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }

        // path params
        if ($productId !== null) {
            $resourcePath = str_replace(
                '{' . 'productId' . '}',
                ObjectSerializer::toPathValue($productId),
                $resourcePath
            );
        }
        // path params
        if ($authorizationId !== null) {
            $resourcePath = str_replace(
                '{' . 'authorizationId' . '}',
                ObjectSerializer::toPathValue($authorizationId),
                $resourcePath
            );
        }

        // form params
        if ($credentialsUsername !== null) {
            $formParams['credentials_username'] = ObjectSerializer::toFormValue($credentialsUsername);
        }
        // form params
        if ($credentialsPassword !== null) {
            $formParams['credentials_password'] = ObjectSerializer::toFormValue($credentialsPassword);
        }
        // form params
        if ($reportUrl !== null) {
            $formParams['report_url'] = ObjectSerializer::toFormValue($reportUrl);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postAuthorizationResultFile
     *
     * Provide a file result to the authorization, e
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  \SplFileObject $fileReport A binary file (e.g. pdf) that contains the result of the authorization (optional)
     * @param  string $originalFilename Optional original filename for the report. If not provided, the filename of uploaded file will be used (optional)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\ReportFile
     */
    public function postAuthorizationResultFile($productId, $authorizationId, $fileReport = null, $originalFilename = null, $notifyClient = 'true', $xFields = null)
    {
        list($response) = $this->postAuthorizationResultFileWithHttpInfo($productId, $authorizationId, $fileReport, $originalFilename, $notifyClient, $xFields);
        return $response;
    }

    /**
     * Operation postAuthorizationResultFileWithHttpInfo
     *
     * Provide a file result to the authorization, e
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  \SplFileObject $fileReport A binary file (e.g. pdf) that contains the result of the authorization (optional)
     * @param  string $originalFilename Optional original filename for the report. If not provided, the filename of uploaded file will be used (optional)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\ReportFile, HTTP status code, HTTP response headers (array of strings)
     */
    public function postAuthorizationResultFileWithHttpInfo($productId, $authorizationId, $fileReport = null, $originalFilename = null, $notifyClient = 'true', $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ReportFile';
        $request = $this->postAuthorizationResultFileRequest($productId, $authorizationId, $fileReport, $originalFilename, $notifyClient, $xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\ReportFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postAuthorizationResultFileAsync
     *
     * Provide a file result to the authorization, e
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  \SplFileObject $fileReport A binary file (e.g. pdf) that contains the result of the authorization (optional)
     * @param  string $originalFilename Optional original filename for the report. If not provided, the filename of uploaded file will be used (optional)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAuthorizationResultFileAsync($productId, $authorizationId, $fileReport = null, $originalFilename = null, $notifyClient = 'true', $xFields = null)
    {
        return $this->postAuthorizationResultFileAsyncWithHttpInfo($productId, $authorizationId, $fileReport, $originalFilename, $notifyClient, $xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postAuthorizationResultFileAsyncWithHttpInfo
     *
     * Provide a file result to the authorization, e
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  \SplFileObject $fileReport A binary file (e.g. pdf) that contains the result of the authorization (optional)
     * @param  string $originalFilename Optional original filename for the report. If not provided, the filename of uploaded file will be used (optional)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAuthorizationResultFileAsyncWithHttpInfo($productId, $authorizationId, $fileReport = null, $originalFilename = null, $notifyClient = 'true', $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ReportFile';
        $request = $this->postAuthorizationResultFileRequest($productId, $authorizationId, $fileReport, $originalFilename, $notifyClient, $xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postAuthorizationResultFile'
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  \SplFileObject $fileReport A binary file (e.g. pdf) that contains the result of the authorization (optional)
     * @param  string $originalFilename Optional original filename for the report. If not provided, the filename of uploaded file will be used (optional)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postAuthorizationResultFileRequest($productId, $authorizationId, $fileReport = null, $originalFilename = null, $notifyClient = 'true', $xFields = null)
    {
        // verify the required parameter 'productId' is set
        if ($productId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $productId when calling postAuthorizationResultFile'
            );
        }
        // verify the required parameter 'authorizationId' is set
        if ($authorizationId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorizationId when calling postAuthorizationResultFile'
            );
        }

        $resourcePath = '/products/{productId}/authorizations/{authorizationId}/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($originalFilename !== null) {
            $queryParams['original_filename'] = ObjectSerializer::toQueryValue($originalFilename);
        }
        // query params
        if ($notifyClient !== null) {
            $queryParams['notify_client'] = ObjectSerializer::toQueryValue($notifyClient);
        }
        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }

        // path params
        if ($productId !== null) {
            $resourcePath = str_replace(
                '{' . 'productId' . '}',
                ObjectSerializer::toPathValue($productId),
                $resourcePath
            );
        }
        // path params
        if ($authorizationId !== null) {
            $resourcePath = str_replace(
                '{' . 'authorizationId' . '}',
                ObjectSerializer::toPathValue($authorizationId),
                $resourcePath
            );
        }

        // form params
        if ($fileReport !== null) {
            $multipart = true;
            $formParams['file_report'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($fileReport), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postClientSnpGroup
     *
     * Get a large group of SNPs
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $snps JSON-encoded list of snps to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\ClientSNP[]
     */
    public function postClientSnpGroup($clientId, $datasetId, $snps, $xFields = null)
    {
        list($response) = $this->postClientSnpGroupWithHttpInfo($clientId, $datasetId, $snps, $xFields);
        return $response;
    }

    /**
     * Operation postClientSnpGroupWithHttpInfo
     *
     * Get a large group of SNPs
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $snps JSON-encoded list of snps to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\ClientSNP[], HTTP status code, HTTP response headers (array of strings)
     */
    public function postClientSnpGroupWithHttpInfo($clientId, $datasetId, $snps, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ClientSNP[]';
        $request = $this->postClientSnpGroupRequest($clientId, $datasetId, $snps, $xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\ClientSNP[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postClientSnpGroupAsync
     *
     * Get a large group of SNPs
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $snps JSON-encoded list of snps to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postClientSnpGroupAsync($clientId, $datasetId, $snps, $xFields = null)
    {
        return $this->postClientSnpGroupAsyncWithHttpInfo($clientId, $datasetId, $snps, $xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postClientSnpGroupAsyncWithHttpInfo
     *
     * Get a large group of SNPs
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $snps JSON-encoded list of snps to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postClientSnpGroupAsyncWithHttpInfo($clientId, $datasetId, $snps, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\ClientSNP[]';
        $request = $this->postClientSnpGroupRequest($clientId, $datasetId, $snps, $xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postClientSnpGroup'
     *
     * @param  string $clientId The UUID of the client (required)
     * @param  string $datasetId The UUID of one of the client&#39;s dataset (required)
     * @param  string $snps JSON-encoded list of snps to be fetched (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postClientSnpGroupRequest($clientId, $datasetId, $snps, $xFields = null)
    {
        // verify the required parameter 'clientId' is set
        if ($clientId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $clientId when calling postClientSnpGroup'
            );
        }
        // verify the required parameter 'datasetId' is set
        if ($datasetId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $datasetId when calling postClientSnpGroup'
            );
        }
        // verify the required parameter 'snps' is set
        if ($snps === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snps when calling postClientSnpGroup'
            );
        }

        $resourcePath = '/clients/{clientId}/datasets/{datasetId}/snps/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }

        // path params
        if ($clientId !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($clientId),
                $resourcePath
            );
        }
        // path params
        if ($datasetId !== null) {
            $resourcePath = str_replace(
                '{' . 'datasetId' . '}',
                ObjectSerializer::toPathValue($datasetId),
                $resourcePath
            );
        }

        // form params
        if ($snps !== null) {
            $formParams['snps'] = ObjectSerializer::toFormValue($snps);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postJwtAuth
     *
     * General-purpose authentication
     *
     * @param  string $username The email for a Client, or the API for a partner product (required)
     * @param  string $password The passowrd for a Client, or the API key for a service (required)
     * @param  string $role The role for which authentication will be made. Value : role_product (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lumminary\Client\Models\JavascriptWebToken
     */
    public function postJwtAuth($username, $password, $role, $xFields = null)
    {
        list($response) = $this->postJwtAuthWithHttpInfo($username, $password, $role, $xFields);
        return $response;
    }

    /**
     * Operation postJwtAuthWithHttpInfo
     *
     * General-purpose authentication
     *
     * @param  string $username The email for a Client, or the API for a partner product (required)
     * @param  string $password The passowrd for a Client, or the API key for a service (required)
     * @param  string $role The role for which authentication will be made. Value : role_product (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lumminary\Client\Models\JavascriptWebToken, HTTP status code, HTTP response headers (array of strings)
     */
    public function postJwtAuthWithHttpInfo($username, $password, $role, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\JavascriptWebToken';
        $request = $this->postJwtAuthRequest($username, $password, $role, $xFields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lumminary\Client\Models\JavascriptWebToken',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postJwtAuthAsync
     *
     * General-purpose authentication
     *
     * @param  string $username The email for a Client, or the API for a partner product (required)
     * @param  string $password The passowrd for a Client, or the API key for a service (required)
     * @param  string $role The role for which authentication will be made. Value : role_product (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postJwtAuthAsync($username, $password, $role, $xFields = null)
    {
        return $this->postJwtAuthAsyncWithHttpInfo($username, $password, $role, $xFields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postJwtAuthAsyncWithHttpInfo
     *
     * General-purpose authentication
     *
     * @param  string $username The email for a Client, or the API for a partner product (required)
     * @param  string $password The passowrd for a Client, or the API key for a service (required)
     * @param  string $role The role for which authentication will be made. Value : role_product (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postJwtAuthAsyncWithHttpInfo($username, $password, $role, $xFields = null)
    {
        $returnType = '\Lumminary\Client\Models\JavascriptWebToken';
        $request = $this->postJwtAuthRequest($username, $password, $role, $xFields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postJwtAuth'
     *
     * @param  string $username The email for a Client, or the API for a partner product (required)
     * @param  string $password The passowrd for a Client, or the API key for a service (required)
     * @param  string $role The role for which authentication will be made. Value : role_product (required)
     * @param  string $xFields An optional fields mask (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postJwtAuthRequest($username, $password, $role, $xFields = null)
    {
        // verify the required parameter 'username' is set
        if ($username === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling postJwtAuth'
            );
        }
        // verify the required parameter 'password' is set
        if ($password === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $password when calling postJwtAuth'
            );
        }
        // verify the required parameter 'role' is set
        if ($role === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $role when calling postJwtAuth'
            );
        }

        $resourcePath = '/auth/jwt';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xFields !== null) {
            $headerParams['X-Fields'] = ObjectSerializer::toHeaderValue($xFields);
        }


        // form params
        if ($username !== null) {
            $formParams['username'] = ObjectSerializer::toFormValue($username);
        }
        // form params
        if ($password !== null) {
            $formParams['password'] = ObjectSerializer::toFormValue($password);
        }
        // form params
        if ($role !== null) {
            $formParams['role'] = ObjectSerializer::toFormValue($role);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postProductAuthorization
     *
     * Signal that processing is complete, without uploading any result
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postProductAuthorization($productId, $authorizationId, $notifyClient = 'true')
    {
        $this->postProductAuthorizationWithHttpInfo($productId, $authorizationId, $notifyClient);
    }

    /**
     * Operation postProductAuthorizationWithHttpInfo
     *
     * Signal that processing is complete, without uploading any result
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postProductAuthorizationWithHttpInfo($productId, $authorizationId, $notifyClient = 'true')
    {
        $returnType = '';
        $request = $this->postProductAuthorizationRequest($productId, $authorizationId, $notifyClient);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postProductAuthorizationAsync
     *
     * Signal that processing is complete, without uploading any result
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postProductAuthorizationAsync($productId, $authorizationId, $notifyClient = 'true')
    {
        return $this->postProductAuthorizationAsyncWithHttpInfo($productId, $authorizationId, $notifyClient)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postProductAuthorizationAsyncWithHttpInfo
     *
     * Signal that processing is complete, without uploading any result
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postProductAuthorizationAsyncWithHttpInfo($productId, $authorizationId, $notifyClient = 'true')
    {
        $returnType = '';
        $request = $this->postProductAuthorizationRequest($productId, $authorizationId, $notifyClient);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postProductAuthorization'
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postProductAuthorizationRequest($productId, $authorizationId, $notifyClient = 'true')
    {
        // verify the required parameter 'productId' is set
        if ($productId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $productId when calling postProductAuthorization'
            );
        }
        // verify the required parameter 'authorizationId' is set
        if ($authorizationId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorizationId when calling postProductAuthorization'
            );
        }

        $resourcePath = '/products/{productId}/authorizations/{authorizationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($notifyClient !== null) {
            $queryParams['notify_client'] = ObjectSerializer::toQueryValue($notifyClient);
        }

        // path params
        if ($productId !== null) {
            $resourcePath = str_replace(
                '{' . 'productId' . '}',
                ObjectSerializer::toPathValue($productId),
                $resourcePath
            );
        }
        // path params
        if ($authorizationId !== null) {
            $resourcePath = str_replace(
                '{' . 'authorizationId' . '}',
                ObjectSerializer::toPathValue($authorizationId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postProductAuthorizationUnfulfillable
     *
     * Catch-all Authorization state, for authorizations that passed all verifications and should reach the partner Product, but cannot be fulfilled for various reasons
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postProductAuthorizationUnfulfillable($productId, $authorizationId, $notifyClient = 'true')
    {
        $this->postProductAuthorizationUnfulfillableWithHttpInfo($productId, $authorizationId, $notifyClient);
    }

    /**
     * Operation postProductAuthorizationUnfulfillableWithHttpInfo
     *
     * Catch-all Authorization state, for authorizations that passed all verifications and should reach the partner Product, but cannot be fulfilled for various reasons
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     *
     * @throws \Lumminary\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postProductAuthorizationUnfulfillableWithHttpInfo($productId, $authorizationId, $notifyClient = 'true')
    {
        $returnType = '';
        $request = $this->postProductAuthorizationUnfulfillableRequest($productId, $authorizationId, $notifyClient);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postProductAuthorizationUnfulfillableAsync
     *
     * Catch-all Authorization state, for authorizations that passed all verifications and should reach the partner Product, but cannot be fulfilled for various reasons
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postProductAuthorizationUnfulfillableAsync($productId, $authorizationId, $notifyClient = 'true')
    {
        return $this->postProductAuthorizationUnfulfillableAsyncWithHttpInfo($productId, $authorizationId, $notifyClient)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postProductAuthorizationUnfulfillableAsyncWithHttpInfo
     *
     * Catch-all Authorization state, for authorizations that passed all verifications and should reach the partner Product, but cannot be fulfilled for various reasons
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postProductAuthorizationUnfulfillableAsyncWithHttpInfo($productId, $authorizationId, $notifyClient = 'true')
    {
        $returnType = '';
        $request = $this->postProductAuthorizationUnfulfillableRequest($productId, $authorizationId, $notifyClient);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postProductAuthorizationUnfulfillable'
     *
     * @param  string $productId The UUID of the product (required)
     * @param  string $authorizationId The UUID of the authorization (required)
     * @param  bool $notifyClient Optional flag to trigger a mail being sent to the client, to notify them of the report being available (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postProductAuthorizationUnfulfillableRequest($productId, $authorizationId, $notifyClient = 'true')
    {
        // verify the required parameter 'productId' is set
        if ($productId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $productId when calling postProductAuthorizationUnfulfillable'
            );
        }
        // verify the required parameter 'authorizationId' is set
        if ($authorizationId === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorizationId when calling postProductAuthorizationUnfulfillable'
            );
        }

        $resourcePath = '/products/{productId}/authorizations/{authorizationId}/unfulfillable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($notifyClient !== null) {
            $queryParams['notify_client'] = ObjectSerializer::toQueryValue($notifyClient);
        }

        // path params
        if ($productId !== null) {
            $resourcePath = str_replace(
                '{' . 'productId' . '}',
                ObjectSerializer::toPathValue($productId),
                $resourcePath
            );
        }
        // path params
        if ($authorizationId !== null) {
            $resourcePath = str_replace(
                '{' . 'authorizationId' . '}',
                ObjectSerializer::toPathValue($authorizationId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
